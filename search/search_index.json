{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Matchbox","text":"<p>Matchbox is a service that matches bare-metal machines to profiles that PXE boot and provision clusters. Machines are matched by labels like MAC or UUID during PXE and profiles specify a kernel/initrd, iPXE config, and Ignition config.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Chainload via iPXE and match hardware labels</li> <li>Provision Fedora CoreOS or Flatcar Linux (powered by Ignition)</li> <li>Authenticated gRPC API for clients (e.g. Terraform)</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Matchbox can be installed from a binary or a container image.</p> <ul> <li>Install Matchbox as a binary, as a container image, or on Kubernetes</li> <li>Setup a PXE-enabled network</li> </ul>"},{"location":"#tutorials","title":"Tutorials","text":"<p>Start provisioning machines with Fedora CoreOS or Flatcar Linux.</p> <ul> <li>Terraform Usage<ul> <li>Fedora CoreOS (live PXE or PXE install to disk)</li> <li>Flatcar Linux (live PXE or PXE install to disk)</li> </ul> </li> <li>Local QEMU/KVM<ul> <li>Fedora CoreOS (live PXE or PXE install to disk)</li> <li>Flatcar Linux (live PXE or PXE install to disk)</li> </ul> </li> </ul>"},{"location":"#related","title":"Related","text":"<ul> <li>dnsmasq - container image to run DHCP, TFTP, and DNS services</li> <li>terraform-provider-matchbox - Terraform provider plugin for Matchbox</li> <li>Typhoon - minimal and free Kubernetes distribution, supporting bare-metal</li> </ul>"},{"location":"api-grpc/","title":"gRPC API","text":""},{"location":"api-grpc/#protos","title":"Protos","text":"<ul> <li>rpc.proto</li> <li>storage.proto</li> </ul>"},{"location":"api-grpc/#client-libraries","title":"Client Libraries","text":"<p>gRPC client libraries</p> <ul> <li>Go</li> </ul>"},{"location":"api-grpc/#client-plugins","title":"Client Plugins","text":"<ul> <li>terraform-provider-matchbox</li> </ul>"},{"location":"api-http/","title":"HTTP API","text":""},{"location":"api-http/#ipxe-script","title":"iPXE script","text":"<p>Serves a static iPXE boot script which gathers client machine attributes and chainloads to the iPXE endpoint. Use DHCP/TFTP to point iPXE clients to this endpoint as the next-server.</p> <pre><code>GET http://matchbox.foo/boot.ipxe\nGET http://matchbox.foo/boot.ipxe.0   // for dnsmasq\n</code></pre> <p>Response</p> <pre><code>#!ipxe\nchain ipxe?uuid=${uuid}&amp;mac=${mac:hexhyp}&amp;domain=${domain}&amp;hostname=${hostname}&amp;serial=${serial}\n</code></pre> <p>Client's booted with the <code>/ipxe.boot</code> endpoint will introspect and make a request to <code>/ipxe</code> with the <code>uuid</code>, <code>mac</code>, <code>hostname</code>, and <code>serial</code> value as query arguments.</p>"},{"location":"api-http/#ipxe","title":"iPXE","text":"<p>Finds the profile for the machine and renders the network boot config (kernel, options, initrd) as an iPXE script.</p> <pre><code>GET http://matchbox.foo/ipxe?label=value\n</code></pre> <p>Query parameters</p> Name Type Description uuid string Hardware UUID mac string MAC address * string Arbitrary label <p>Response</p> <pre><code>#!ipxe\nkernel /assets/coreos/1967.3.0/coreos_production_pxe.vmlinuz coreos.config.url=http://matchbox.foo:8080/ignition?uuid=${uuid}&amp;mac=${mac:hexhyp} coreos.first_boot=1 coreos.autologin\ninitrd  /assets/coreos/1967.3.0/coreos_production_pxe_image.cpio.gz\nboot\n</code></pre>"},{"location":"api-http/#grub2","title":"GRUB2","text":"<p>Finds the profile for the machine and renders the network boot config as a GRUB config. Use DHCP/TFTP to point GRUB clients to this endpoint as the next-server.</p> <pre><code>GET http://matchbox.foo/grub?label=value\n</code></pre> <p>Query parameters</p> Name Type Description uuid string Hardware UUID mac string MAC address * string Arbitrary label <p>Response</p> <pre><code>default=0\ntimeout=1\nmenuentry \"CoreOS\" {\necho \"Loading kernel\"\nlinuxefi \"(http;matchbox.foo:8080)/assets/coreos/1967.3.0/coreos_production_pxe.vmlinuz\" \"coreos.autologin\" \"coreos.config.url=http://matchbox.foo:8080/ignition\" \"coreos.first_boot\"\necho \"Loading initrd\"\ninitrdefi \"(http;matchbox.foo:8080)/assets/coreos/1967.3.0/coreos_production_pxe_image.cpio.gz\"\n}\n</code></pre>"},{"location":"api-http/#cloud-config","title":"Cloud config","text":"<p>DEPRECATED: Finds the profile matching the machine and renders the corresponding Cloud-Config with group metadata, selectors, and query params.</p> <pre><code>GET http://matchbox.foo/cloud?label=value\n</code></pre> <p>Query Parameters</p> Name Type Description uuid string Hardware UUID mac string MAC address * string Arbitrary label <p>Response</p> <pre><code>#cloud-config\ncoreos:\n  units:\n    - name: etcd2.service\n      command: start\n    - name: fleet.service\n      command: start\n</code></pre>"},{"location":"api-http/#ignition-config","title":"Ignition Config","text":"<p>Finds the profile matching the machine and renders the corresponding Ignition for machine consumption.</p> <pre><code>GET http://matchbox.foo/ignition?label=value\n</code></pre> <p>Query parameters</p> Name Type Description uuid string Hardware UUID mac string MAC address * string Arbitrary label <p>Response</p> <pre><code>{\n  \"ignition\": { \"version\": \"3.3.0\" },\n  \"systemd\": {\n    \"units\": [{\n      \"name\": \"example.service\",\n      \"enabled\": true,\n      \"contents\": \"[Service]\\nType=oneshot\\nExecStart=/usr/bin/echo Hello World\\n\\n[Install]\\nWantedBy=multi-user.target\"\n    }]\n  }\n}\n</code></pre>"},{"location":"api-http/#generic-config","title":"Generic config","text":"<p>Finds the profile matching the machine and renders the corresponding generic config with group metadata, selectors, and query params.</p> <pre><code>GET http://matchbox.foo/generic?label=value\n</code></pre> <p>Query parameters</p> Name Type Description uuid string Hardware UUID mac string MAC address * string Arbitrary label <p>Response</p> <pre><code>{\n  \u201cuuid\u201d: \u201c\u201d,\n  \u201cmac\u201d: \u201c52:54:00:a1:9c:ae\u201d,\n  \u201cosInstalled\u201d: true,\n  \u201crawQuery\u201d: \u201cmac=52:54:00:a1:9c:ae&amp;os=installed\u201d\n}\n</code></pre>"},{"location":"api-http/#metadata","title":"Metadata","text":"<p>Finds the matching machine group and renders the group metadata, selectors, and query params in an \"env file\" style response.</p> <pre><code>GET http://matchbox.foo/metadata?mac=52-54-00-a1-9c-ae&amp;foo=bar&amp;count=3&amp;gate=true\n</code></pre> <p>Query Parameters</p> Name Type Description uuid string Hardware UUID mac string MAC address * string Arbitrary label <p>Response</p> <pre><code>META=data\nETCD_NAME=node1\nSOME_NESTED_DATA=some-value\nMAC=52:54:00:a1:9c:ae\nREQUEST_QUERY_MAC=52:54:00:a1:9c:ae\nREQUEST_QUERY_FOO=bar\nREQUEST_QUERY_COUNT=3\nREQUEST_QUERY_GATE=true\nREQUEST_RAW_QUERY=mac=52-54-00-a1-9c-ae&amp;foo=bar&amp;count=3&amp;gate=true\n</code></pre>"},{"location":"api-http/#openpgp-signatures","title":"OpenPGP signatures","text":"<p>OpenPGP signature endpoints serve detached binary and ASCII armored signatures of rendered configs, if enabled. See OpenPGP Signing.</p> Endpoint Signature Endpoint ASCII Signature Endpoint iPXE <code>http://matchbox.foo/ipxe.sig</code> <code>http://matchbox.foo/ipxe.asc</code> GRUB2 <code>http://bootcf.foo/grub.sig</code> <code>http://matchbox.foo/grub.asc</code> Ignition <code>http://matchbox.foo/ignition.sig</code> <code>http://matchbox.foo/ignition.asc</code> Cloud-Config <code>http://matchbox.foo/cloud.sig</code> <code>http://matchbox.foo/cloud.asc</code> Generic <code>http://matchbox.foo/generic.sig</code> <code>http://matchbox.foo/generic.asc</code> Metadata <code>http://matchbox.foo/metadata.sig</code> <code>http://matchbox.foo/metadata.asc</code> <p>Get a config and its detached ASCII armored signature.</p> <pre><code>GET http://matchbox.foo/ipxe?label=value\nGET http://matchbox.foo/ipxe.asc?label=value\n</code></pre> <p>Response</p> <pre><code>-----BEGIN PGP SIGNATURE-----\n\nwsBcBAEBCAAQBQJWoDHyCRCzUpbPLRRcKAAAqQ8IAGD+eC9kzc/U7h9tgwvvWwm9\nsuTmVSGlzC5RwTRXg6CKuW31m3WAin2b5zWRPa7MxxanYMhhBbOfrqg/4xi1tfdE\nw7ipmmgftl3re0np75Jt9K1rwGXUHTCs3yooz/zvqSvNSobG13FL5tp+Jl7a22wE\n+W7x9BukTytVgNLt3IDIxsJ/rAEYUm4zySftooDbFVKj/SK5w8xg4zLmE6Jxz6wp\neaMlL1TEXy3NaFR0+hgbqM/tgeV2j6pmho8yaPF63iPnksH+gdmPiwasCfpSaJyr\nNO+p24BL3PHZyKw0nsrm275C913OxEVgnNZX7TQltaweW23Cd1YBNjcfb3zv+Zo=\n=mqZK\n-----END PGP SIGNATURE-----\n</code></pre>"},{"location":"api-http/#assets","title":"Assets","text":"<p>If you need to serve static assets (e.g. kernel, initrd), <code>matchbox</code> can serve arbitrary assets from the <code>-assets-path</code>.</p> <pre><code>matchbox.foo/assets/\n\u2514\u2500\u2500 coreos\n    \u2514\u2500\u2500 1967.3.0\n        \u251c\u2500\u2500 coreos_production_pxe.vmlinuz\n        \u2514\u2500\u2500 coreos_production_pxe_image.cpio.gz\n    \u2514\u2500\u2500 1153.0.0\n        \u251c\u2500\u2500 coreos_production_pxe.vmlinuz\n        \u2514\u2500\u2500 coreos_production_pxe_image.cpio.gz\n</code></pre>"},{"location":"cloud-config/","title":"Cloud Config","text":"<p>Warning</p> <p>Migrate to Ignition configs. Cloud-Config support will be removed in the future.</p> <p>CoreOS Cloud-Config is a system for configuring machines with a Cloud-Config file or executable script from user-data. Cloud-Config runs in userspace on each boot and implements a subset of the cloud-init spec. See the cloud-config docs for details.</p> <p>Cloud-Config template files can be added in <code>/var/lib/matchbox/cloud</code> or in a <code>cloud</code> subdirectory of a custom <code>-data-path</code>. Template files may contain Go template elements which will be evaluated with group metadata, selectors, and query params.</p> <pre><code>/var/lib/matchbox\n\u251c\u2500\u2500 cloud\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 cloud.yaml\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 script.sh\n\u251c\u2500\u2500 ignition\n\u2514\u2500\u2500 profiles\n</code></pre>"},{"location":"cloud-config/#reference","title":"Reference","text":"<p>Reference a Cloud-Config in a Profile with <code>cloud_id</code>. When PXE booting, use the kernel option <code>cloud-config-url</code> to point to <code>matchbox</code> cloud-config endpoint.</p>"},{"location":"cloud-config/#examples","title":"Examples","text":"<p>Here is an example Cloud-Config which starts some units and writes a file.</p> <pre><code>#cloud-config\ncoreos:\n  units:\n    - name: etcd2.service\n      command: start\n    - name: fleet.service\n      command: start\nwrite_files:\n  - path: \"/home/core/welcome\"\n    owner: \"core\"\n    permissions: \"0644\"\n    content: |\n      {{.greeting}}\n</code></pre> <p>The Cloud-Config Validator is also useful for checking your Cloud-Config files for errors.</p>"},{"location":"cloud-config/#comparison-with-ignition","title":"Comparison with Ignition","text":"<p>Cloud-Config starts after userspace has started, on every boot. Ignition starts before PID 1 and only runs on the first boot. Ignition favors immutable infrastructure.</p> <p>Ignition is favored as the replacement for CoreOS Cloud-Config. Tasks often only need to be run once and can be performed more easily before systemd has started (e.g. configuring networking). Ignition can write service units for tasks that need to be run on each boot. Instead of depending on Cloud-Config variable substitution, Ignition favors using systemd's EnvironmentFile expansion to start units with a metadata file from a metadata source.</p>"},{"location":"config/","title":"Flags and variables","text":"<p>Configuration arguments can be provided as flags or as environment variables.</p> flag variable default example -address MATCHBOX_ADDRESS 127.0.0.1:8080 0.0.0.0:8080 -log-level MATCHBOX_LOG_LEVEL info critical, error, warning, notice, info, debug -data-path MATCHBOX_DATA_PATH /var/lib/matchbox ./examples -assets-path MATCHBOX_ASSETS_PATH /var/lib/matchbox/assets ./examples/assets -rpc-address MATCHBOX_RPC_ADDRESS (gRPC API disabled) 0.0.0.0:8081 -cert-file MATCHBOX_CERT_FILE /etc/matchbox/server.crt ./examples/etc/matchbox/server.crt -key-file MATCHBOX_KEY_FILE /etc/matchbox/server.key ./examples/etc/matchbox/server.key -ca-file MATCHBOX_CA_FILE /etc/matchbox/ca.crt ./examples/etc/matchbox/ca.crt -key-ring-path MATCHBOX_KEY_RING_PATH (no key ring) ~/.secrets/vault/matchbox/secring.gpg (no flag) MATCHBOX_PASSPHRASE (no passphrase) \"secret passphrase\""},{"location":"config/#files-and-directories","title":"Files and directories","text":"Data Default Location data /var/lib/matchbox/{profiles,groups,ignition,cloud,generic} assets /var/lib/matchbox/assets gRPC API TLS Credentials Default Location CA certificate /etc/matchbox/ca.crt Server certificate /etc/matchbox/server.crt Server private key /etc/matchbox/server.key Client certificate /etc/matchbox/client.crt Client private key /etc/matchbox/client.key"},{"location":"config/#version","title":"Version","text":"<pre><code>$ ./bin/matchbox -version\n$ sudo docker run quay.io/poseidon/matchbox:latest -version\n</code></pre>"},{"location":"config/#usage","title":"Usage","text":"<p>Run the binary.</p> <pre><code>$ ./bin/matchbox -address=0.0.0.0:8080 -log-level=debug -data-path=examples -assets-path=examples/assets\n</code></pre> <p>Run the latest Docker image.</p> <pre><code>$ sudo docker run -p 8080:8080 --rm -v $PWD/examples/assets:/var/lib/matchbox/assets:Z quay.io/poseidon/matchbox:latest -address=0.0.0.0:8080 -log-level=debug\n</code></pre>"},{"location":"config/#with-examples","title":"With examples","text":"<p>Mount <code>examples</code> to pre-load the example machine groups and profiles. Run the container.</p> <pre><code>$ sudo docker run -p 8080:8080 --rm -v $PWD/examples:/var/lib/matchbox:Z -v $PWD/examples/groups/etcd:/var/lib/matchbox/groups:Z quay.io/poseidon/matchbox:latest -address=0.0.0.0:8080 -log-level=debug\n</code></pre>"},{"location":"config/#with-grpc-api","title":"With gRPC API","text":"<p>The gRPC API allows clients with a TLS client certificate and key to make RPC requests to programmatically create or update <code>matchbox</code> resources. The API can be enabled with the <code>-rpc-address</code> flag and by providing a TLS server certificate and key with <code>-cert-file</code> and <code>-key-file</code> and a CA certificate for authenticating clients with <code>-ca-file</code>.</p> <p>Run the binary with TLS credentials from <code>examples/etc/matchbox</code>.</p> <pre><code>$ ./bin/matchbox -address=0.0.0.0:8080 -rpc-address=0.0.0.0:8081 -log-level=debug -data-path=examples -assets-path=examples/assets -cert-file examples/etc/matchbox/server.crt -key-file examples/etc/matchbox/server.key -ca-file examples/etc/matchbox/ca.crt\n</code></pre> <p>Clients, such as <code>bootcmd</code>, verify the server's certificate with a CA bundle passed via <code>-ca-file</code> and present a client certificate and key via <code>-cert-file</code> and <code>-key-file</code> to cal the gRPC API.</p> <pre><code>$ ./bin/bootcmd profile list --endpoints 127.0.0.1:8081 --ca-file examples/etc/matchbox/ca.crt --cert-file examples/etc/matchbox/client.crt --key-file examples/etc/matchbox/client.key\n</code></pre>"},{"location":"config/#with-docker","title":"With docker","text":"<p>Run the Docker image with TLS credentials from <code>examples/etc/matchbox</code>.</p> <pre><code>$ sudo docker run -p 8080:8080 -p 8081:8081 --rm -v $PWD/examples:/var/lib/matchbox:Z -v $PWD/examples/etc/matchbox:/etc/matchbox:Z,ro -v $PWD/examples/groups/etcd:/var/lib/matchbox/groups:Z quay.io/poseidon/matchbox:latest -address=0.0.0.0:8080 -rpc-address=0.0.0.0:8081 -log-level=debug\n</code></pre> <p>A <code>bootcmd</code> client can call the gRPC API running at the IP used in the Docker example.</p> <pre><code>$ ./bin/bootcmd profile list --endpoints 127.0.0.1:8081 --ca-file examples/etc/matchbox/ca.crt --cert-file examples/etc/matchbox/client.crt --key-file examples/etc/matchbox/client.key\n</code></pre>"},{"location":"config/#with-openpgp-signing","title":"With openPGP Signing","text":"<p>Run with the binary with a test key.</p> <pre><code>$ export MATCHBOX_PASSPHRASE=test\n$ ./bin/matchbox -address=0.0.0.0:8080 -key-ring-path matchbox/sign/fixtures/secring.gpg -data-path=examples -assets-path=examples/assets\n</code></pre> <p>Run the container image with a test key.</p> <pre><code>$ sudo docker run -p 8080:8080 --rm --env MATCHBOX_PASSPHRASE=test -v $PWD/examples:/var/lib/matchbox:Z -v $PWD/examples/groups/etcd:/var/lib/matchbox/groups:Z -v $PWD/matchbox/sign/fixtures:/secrets:Z quay.io/poseidon/matchbox:latest -address=0.0.0.0:8080 -log-level=debug -key-ring-path secrets/secring.gpg\n</code></pre>"},{"location":"deployment/","title":"Installation","text":"<p>This guide walks through deploying the <code>matchbox</code> service on a Linux host (as a binary or container image) or on a Kubernetes cluster.</p>"},{"location":"deployment/#provisoner","title":"Provisoner","text":"<p>Matchbox is a service for network booting and provisioning machines to create Fedora CoreOS or Flatcar Linux clusters. Matchbox may installed on a host server or Kubernetes cluster that can serve configs to client machines in a lab or datacenter.</p> <p>Choose one of the supported installation options:</p> <ul> <li>Matchbox binary</li> <li>Container image</li> <li>Kubernetes manifests</li> </ul>"},{"location":"deployment/#download","title":"Download","text":"<p>Download the latest Matchbox release.</p> <pre><code>$ wget https://github.com/poseidon/matchbox/releases/download/v0.10.0/matchbox-v0.10.0-linux-amd64.tar.gz\n$ wget https://github.com/poseidon/matchbox/releases/download/v0.10.0/matchbox-v0.10.0-linux-amd64.tar.gz.asc\n</code></pre> <p>Verify the release has been signed by Dalton Hubble's GPG Key's signing subkey.</p> <pre><code>$ gpg --keyserver keyserver.ubuntu.com --recv-key 2E3D92BF07D9DDCCB3BAE4A48F515AD1602065C8\n$ gpg --verify matchbox-v0.10.0-linux-amd64.tar.gz.asc matchbox-v0.10.0-linux-amd64.tar.gz\ngpg: Good signature from \"Dalton Hubble &lt;dghubble@gmail.com&gt;\"\n</code></pre> <p>Untar the release.</p> <pre><code>$ tar xzvf matchbox-v0.10.0-linux-amd64.tar.gz\n$ cd matchbox-v0.10.0-linux-amd64\n</code></pre>"},{"location":"deployment/#install","title":"Install","text":"<p>Run Matchbox as a binary, a container image, or on Kubernetes.</p>"},{"location":"deployment/#matchbox-binary","title":"Matchbox Binary","text":"<p>Pre-built binaries are available for generic Linux distributions. Copy the <code>matchbox</code> static binary to an appropriate location on the host.</p> <pre><code>$ sudo cp matchbox /usr/local/bin\n</code></pre>"},{"location":"deployment/#set-up-usergroup","title":"Set up User/Group","text":"<p>The <code>matchbox</code> service should be run by a non-root user with access to the <code>matchbox</code> data directory (<code>/var/lib/matchbox</code>). Create a <code>matchbox</code> user and group.</p> <pre><code>$ sudo useradd -U matchbox\n$ sudo mkdir -p /var/lib/matchbox/assets\n$ sudo chown -R matchbox:matchbox /var/lib/matchbox\n</code></pre>"},{"location":"deployment/#create-systemd-service","title":"Create systemd service","text":"<p>Copy the provided <code>matchbox</code> systemd unit file.</p> <pre><code>$ sudo cp contrib/systemd/matchbox.service /etc/systemd/system/matchbox.service\n</code></pre>"},{"location":"deployment/#systemd-dropins","title":"systemd dropins","text":"<p>Customize Matchbox by editing the systemd unit or adding a systemd dropin. Find the complete set of <code>matchbox</code> flags and environment variables at config.</p> <pre><code>$ sudo systemctl edit matchbox\n</code></pre> <p>By default, the read-only HTTP machine endpoint will be exposed on port 8080.</p> <pre><code># /etc/systemd/system/matchbox.service.d/override.conf\n[Service]\nEnvironment=\"MATCHBOX_ADDRESS=0.0.0.0:8080\"\nEnvironment=\"MATCHBOX_LOG_LEVEL=debug\"\n</code></pre> <p>A common customization is enabling the gRPC API to allow clients with a TLS client certificate to change machine configs.</p> <pre><code># /etc/systemd/system/matchbox.service.d/override.conf\n[Service]\nEnvironment=\"MATCHBOX_ADDRESS=0.0.0.0:8080\"\nEnvironment=\"MATCHBOX_RPC_ADDRESS=0.0.0.0:8081\"\n</code></pre> <p>Customize <code>matchbox</code> to suit your preferences.</p>"},{"location":"deployment/#start","title":"Start","text":"<p>Start the Matchbox service and enable it if you'd like it to start on every boot.</p> <pre><code>$ sudo systemctl daemon-reload\n$ sudo systemctl start matchbox\n$ sudo systemctl enable matchbox\n</code></pre>"},{"location":"deployment/#container-image","title":"Container Image","text":"<p>Run the container image with Podman,</p> <pre><code>mkdir -p /var/lib/matchbox/assets\npodman run --net=host --rm -v /var/lib/matchbox:/var/lib/matchbox:Z -v /etc/matchbox:/etc/matchbox:Z,ro quay.io/poseidon/matchbox:v0.10.0 -address=0.0.0.0:8080 -rpc-address=0.0.0.0:8081 -log-level=debug\n</code></pre> <p>Or with Docker,</p> <pre><code>mkdir -p /var/lib/matchbox/assets\nsudo docker run --net=host --rm -v /var/lib/matchbox:/var/lib/matchbox:Z -v /etc/matchbox:/etc/matchbox:Z,ro quay.io/poseidon/matchbox:v0.10.0 -address=0.0.0.0:8080 -rpc-address=0.0.0.0:8081 -log-level=debug\n</code></pre> <p>Create machine profiles, groups, or Ignition configs by adding files to <code>/var/lib/matchbox</code>.</p>"},{"location":"deployment/#kubernetes","title":"Kubernetes","text":"<p>Install Matchbox on a Kubernetes cluster with the example manifests.</p> <pre><code>$ kubectl apply -R -f contrib/k8s\n$ kubectl get services\nNAME                 CLUSTER-IP   EXTERNAL-IP   PORT(S)             AGE\nmatchbox             10.3.0.145   &lt;none&gt;        8080/TCP,8081/TCP   46m\n</code></pre> <p>Example manifests in contrib/k8s enable the gRPC API to allow client apps to update matchbox objects. Generate TLS server certificates for <code>matchbox-rpc.example.com</code> as shown and create a Kubernetes secret. Alternately, edit the example manifests if you don't need the gRPC API enabled.</p> <pre><code>$ kubectl create secret generic matchbox-rpc --from-file=ca.crt --from-file=server.crt --from-file=server.key\n</code></pre> <p>Create an Ingress resource to expose the HTTP read-only and gRPC API endpoints. The Ingress example requires the cluster to have a functioning Nginx Ingress Controller.</p> <pre><code>$ kubectl create -f contrib/k8s/matchbox-ingress.yaml\n$ kubectl get ingress\nNAME      HOSTS                                          ADDRESS            PORTS     AGE\nmatchbox       matchbox.example.com                      10.128.0.3,10...   80        29m\nmatchbox-rpc   matchbox-rpc.example.com                  10.128.0.3,10...   80, 443   29m\n</code></pre> <p>Add DNS records <code>matchbox.example.com</code> and <code>matchbox-rpc.example.com</code> to route traffic to the Ingress Controller.</p> <p>Verify <code>http://matchbox.example.com</code> responds with the text \"matchbox\" and verify gRPC clients can connect to <code>matchbox-rpc.example.com:443</code>.</p> <pre><code>$ curl http://matchbox.example.com\n$ openssl s_client -connect matchbox-rpc.example.com:443 -CAfile ca.crt -cert client.crt -key client.key\n</code></pre>"},{"location":"deployment/#firewall","title":"Firewall","text":"<p>Allow your port choices on the provisioner's firewall so the clients can access the service. Here are the commands for those using <code>firewalld</code>:</p> <pre><code>$ sudo firewall-cmd --zone=MYZONE --add-port=8080/tcp --permanent\n$ sudo firewall-cmd --zone=MYZONE --add-port=8081/tcp --permanent\n</code></pre>"},{"location":"deployment/#generate-tls-certificates","title":"Generate TLS Certificates","text":"<p>The Matchbox gRPC API allows clients (terraform-provider-matchbox) to create and update Matchbox resources. TLS credentials are needed for client authentication and to establish a secure communication channel. Client machines (those PXE booting) read from the HTTP endpoints and do not require this setup.</p> <p>The <code>cert-gen</code> helper script generates a self-signed CA, server certificate, and client certificate. Prefer your organization's PKI, if possible</p> <p>Navigate to the <code>scripts/tls</code> directory.</p> <pre><code>$ cd scripts/tls\n</code></pre> <p>Export <code>SAN</code> to set the Subject Alt Names which should be used in certificates. Provide the fully qualified domain name or IP (discouraged) where Matchbox will be installed.</p> <pre><code># DNS or IP Subject Alt Names where matchbox runs\n$ export SAN=DNS.1:matchbox.example.com,IP.1:172.17.0.2\n</code></pre> <p>Generate a <code>ca.crt</code>, <code>server.crt</code>, <code>server.key</code>, <code>client.crt</code>, and <code>client.key</code>.</p> <pre><code>$ ./cert-gen\n</code></pre> <p>Move TLS credentials to the matchbox server's default location.</p> <pre><code>$ sudo mkdir -p /etc/matchbox\n$ sudo cp ca.crt server.crt server.key /etc/matchbox\n$ sudo chown -R matchbox:matchbox /etc/matchbox\n</code></pre> <p>Save <code>client.crt</code>, <code>client.key</code>, and <code>ca.crt</code> for later use (e.g. <code>~/.matchbox</code>).</p> <pre><code>$ mkdir -p ~/.matchbox\n$ cp client.crt client.key ca.crt ~/.matchbox/\n</code></pre>"},{"location":"deployment/#verify","title":"Verify","text":"<p>Verify the matchbox service is running and can be reached by client machines (those being provisioned).</p> <pre><code>$ systemctl status matchbox   # Matchbox binary method\n$ dig matchbox.example.com\n</code></pre> <p>Verify you receive a response from the HTTP and API endpoints.</p> <pre><code>$ curl http://matchbox.example.com:8080\nmatchbox\n</code></pre> <p>If you enabled the gRPC API,</p> <pre><code>$ openssl s_client -connect matchbox.example.com:8081 -CAfile scripts/tls/ca.crt -cert scripts/tls/client.crt -key scripts/tls/client.key\nCONNECTED(00000003)\ndepth=1 CN = fake-ca\nverify return:1\ndepth=0 CN = fake-server\nverify return:1\n---\nCertificate chain\n 0 s:/CN=fake-server\n   i:/CN=fake-ca\n---\n....\n</code></pre>"},{"location":"deployment/#download-images-optional","title":"Download Images (optional)","text":"<p>Matchbox can serve OS images in development or lab environments to reduce bandwidth usage and increase the speed of PXE boots and installs to disk.</p> <p>Download a recent Fedora CoreOS or Flatcar Linux release.</p> <pre><code>$ ./scripts/get-fedora-coreos stable 36.20220906.3.2 .\n$ ./scripts/get-flatcar stable 3227.2.0 .\n</code></pre> <p>Move the images to <code>/var/lib/matchbox/assets</code>,</p> <pre><code>/var/lib/matchbox/assets/fedora-coreos/\n\u251c\u2500\u2500 fedora-coreos-36.20220906.3.2-live-initramfs.x86_64.img\n\u251c\u2500\u2500 fedora-coreos-36.20220906.3.2-live-kernel-x86_64\n\u251c\u2500\u2500 fedora-coreos-36.20220906.3.2-live-rootfs.x86_64.img\n\n/var/lib/matchbox/assets/flatcar/\n\u2514\u2500\u2500 3227.2.0\n    \u251c\u2500\u2500 Flatcar_Image_Signing_Key.asc\n    \u251c\u2500\u2500 flatcar_production_image.bin.bz2\n    \u251c\u2500\u2500 flatcar_production_image.bin.bz2.sig\n    \u251c\u2500\u2500 flatcar_production_pxe_image.cpio.gz\n    \u251c\u2500\u2500 flatcar_production_pxe_image.cpio.gz.sig\n    \u251c\u2500\u2500 flatcar_production_pxe.vmlinuz\n    \u251c\u2500\u2500 flatcar_production_pxe.vmlinuz.sig\n    \u2514\u2500\u2500 version.txt\n</code></pre> <p>and verify the images are accessible.</p> <pre><code>$ curl http://matchbox.example.com:8080/assets/fedora-coreos/\n&lt;pre&gt;...\n</code></pre> <p>For large production environments, use a cache proxy or mirror suitable for your environment to serve images.</p>"},{"location":"deployment/#network","title":"Network","text":"<p>Review network setup with your network administrator to set up DHCP, TFTP, and DNS services on your network. At a high level, your goals are to:</p> <ul> <li>Chainload PXE firmwares to iPXE</li> <li>Point iPXE client machines to the <code>matchbox</code> iPXE HTTP endpoint <code>http://matchbox.example.com:8080/boot.ipxe</code></li> <li>Ensure <code>matchbox.example.com</code> resolves to your <code>matchbox</code> deployment</li> </ul> <p>Poseidon provides dnsmasq as <code>quay.io/poseidon/dnsmasq</code>.</p>"},{"location":"deployment/#tls","title":"TLS","text":"<p>Matchbox can serve the read-only HTTP API with TLS.</p> Name Type Description -web-ssl bool true/false -web-cert-file string Path to the server TLS certificate file -web-key-file string Path to the server TLS key file <p>However, it is more common to use an Ingress Controller (Kubernetes) to terminate TLS.</p>"},{"location":"deployment/#operational-notes","title":"Operational notes","text":"<ul> <li>Secrets: Matchbox can be run as a public facing service. However, you must follow best practices and avoid writing secret material into machine user-data. Instead, load secret materials from an internal secret store.</li> <li>Storage: Example manifests use Kubernetes <code>emptyDir</code> volumes to store <code>matchbox</code> data. Swap those out for a Kubernetes persistent volume if available.</li> </ul>"},{"location":"getting-started-docker/","title":"Getting started with Docker","text":"<p>In this tutorial, we'll run <code>matchbox</code> on a Linux machine with Docker to network boot and provision local QEMU/KVM machines as Fedora CoreOS or Flatcar Linux machines. You'll be able to test network setups and Ignition provisioning.</p> <p>Note</p> <p>To provision physical machines, see network setup and deployment.</p>"},{"location":"getting-started-docker/#requirements","title":"Requirements","text":"<p>Install the package dependencies and start the Docker daemon.</p> <pre><code>$ # Fedora\n$ sudo dnf install docker virt-install virt-manager\n$ sudo systemctl start docker\n\n$ # Debian/Ubuntu\n$ # check Docker's docs to install Docker 1.8+ on Debian/Ubuntu\n$ sudo apt-get install virt-manager virtinst qemu-kvm\n</code></pre> <p>Clone the matchbox source which contains the examples and scripts.</p> <pre><code>$ git clone https://github.com/poseidon/matchbox.git\n$ cd matchbox\n</code></pre> <p>Download Fedora CoreOS or Flatcar Linux image assets to <code>examples/assets</code>.</p> <pre><code>$ ./scripts/get-fedora-coreos stable 36.20220906.3.2 ./examples/assets\n$ ./scripts/get-flatcar stable 3227.2.0 ./examples/assets\n</code></pre> <p>For development convenience, add <code>/etc/hosts</code> entries for nodes so they may be referenced by name.</p> <pre><code># /etc/hosts\n...\n172.17.0.21 node1.example.com\n172.17.0.22 node2.example.com\n172.17.0.23 node3.example.com\n</code></pre>"},{"location":"getting-started-docker/#containers","title":"Containers","text":"<p>Run the <code>matchbox</code> and <code>dnsmasq</code> services on the <code>docker0</code> bridge. <code>dnsmasq</code> will run DHCP, DNS and TFTP services to create a suitable network boot environment. <code>matchbox</code> will serve configs to machines as they PXE boot.</p> <p>The <code>devnet</code> convenience script can start these services and accepts the name of any example in examples.</p> <pre><code>$ sudo ./scripts/devnet create fedora-coreos\n</code></pre> <p>Inspect the logs.</p> <pre><code>$ sudo ./scripts/devnet status\n</code></pre> <p>Inspect the examples and Matchbox endpoints to see how machines (e.g. node1 with MAC <code>52:54:00:a1:9c:ae</code>) are mapped to Profiles, and therefore iPXE and Ignition configs.</p> <ul> <li>iPXE http://127.0.0.1:8080/ipxe?mac=52:54:00:a1:9c:ae</li> <li>Ignition http://127.0.0.1:8080/ignition?mac=52:54:00:a1:9c:ae</li> <li>Metadata http://127.0.0.1:8080/metadata?mac=52:54:00:a1:9c:ae</li> </ul>"},{"location":"getting-started-docker/#manual","title":"Manual","text":"<p>If you prefer to start the containers yourself, instead of using <code>devnet</code>,</p> <pre><code>$ sudo docker run -p 8080:8080 --rm -v $PWD/examples:/var/lib/matchbox:Z -v $PWD/examples/groups/fedora-coreos:/var/lib/matchbox/groups:Z quay.io/poseidon/matchbox:latest -address=0.0.0.0:8080 -log-level=debug\n$ sudo docker run --name dnsmasq --cap-add=NET_ADMIN -v $PWD/contrib/dnsmasq/docker0.conf:/etc/dnsmasq.conf:Z quay.io/poseidon/dnsmasq -d\n</code></pre>"},{"location":"getting-started-docker/#client-vms","title":"Client VMs","text":"<p>Create QEMU/KVM VMs which have known hardware attributes. The nodes will be attached to the <code>docker0</code> bridge, where Docker containers run.</p> <pre><code>$ sudo ./scripts/libvirt create\n</code></pre> <p>If you provisioned nodes with an SSH key, you can SSH after bring-up.</p> <pre><code>$ ssh core@node1.example.com\n</code></pre> <p>If you set a <code>console=ttyS0</code> kernel arg, you can connect to the serial console of any node (ctrl+] to exit).</p> <pre><code>$ sudo virsh console node1\n</code></pre> <p>You can also use <code>virt-manager</code> to watch the console.</p> <pre><code>$ sudo virt-manager\n</code></pre> <p>Use the wrapper script to act on all nodes.</p> <pre><code>$ sudo ./scripts/libvirt [start|reboot|shutdown|poweroff|destroy]\n</code></pre>"},{"location":"getting-started-docker/#verify","title":"Verify","text":"<p>The VMs should network boot and provision themselves as declared.</p> <pre><code>cat /etc/os-release\n</code></pre>"},{"location":"getting-started-docker/#clean-up","title":"Clean up","text":"<p>Clean up the containers and VM machines.</p> <pre><code>$ sudo ./scripts/devnet destroy\n$ sudo ./scripts/libvirt destroy\n</code></pre>"},{"location":"getting-started-docker/#going-further","title":"Going Further","text":"<p>Learn more about matchbox or explore the other examples.</p> <p>Try different examples and Ignition declarations:</p> <ul> <li>Declare an SSH authorized public key (see examples README)</li> <li>Declare a systemd unit</li> <li>Declare file or directory content</li> </ul>"},{"location":"getting-started/","title":"Getting started","text":"<p>In this tutorial, we'll use <code>matchbox</code> with Terraform to provision Fedora CoreOS or Flatcar Linux machines.</p> <p>We'll install the <code>matchbox</code> service, setup a PXE network boot environment, and use Terraform configs to declare infrastructure and apply resources on <code>matchbox</code>.</p>"},{"location":"getting-started/#matchbox","title":"matchbox","text":"<p>Install <code>matchbox</code> on a host server or Kubernetes cluster. Generate TLS credentials and enable the gRPC API as directed. Save the <code>ca.crt</code>, <code>client.crt</code>, and <code>client.key</code> on your local machine (e.g. <code>~/.matchbox</code>).</p> <ul> <li>Installing on a Linux distro</li> <li>Installing on Kubernetes</li> <li>Running with docker</li> </ul> <p>Verify the matchbox read-only HTTP endpoints are accessible.</p> <pre><code>$ curl http://matchbox.example.com:8080\nmatchbox\n</code></pre> <p>Verify your TLS client certificate and key can be used to access the gRPC API.</p> <pre><code>$ openssl s_client -connect matchbox.example.com:8081 \\\n  -CAfile ~/.matchbox/ca.crt \\\n  -cert ~/.matchbox/client.crt \\\n  -key ~/.matchbox/client.key\n</code></pre>"},{"location":"getting-started/#terraform","title":"Terraform","text":"<p>Install Terraform v0.13+ on your system.</p> <pre><code>$ terraform version\nTerraform v1.1.8\n</code></pre>"},{"location":"getting-started/#examples","title":"Examples","text":"<p>Clone the matchbox source.</p> <pre><code>$ git clone https://github.com/poseidon/matchbox.git\n$ cd matchbox/examples/terraform\n</code></pre> <p>Select from the Terraform examples. For example,</p> <ul> <li><code>fedora-coreos-install</code> - PXE boot, install Fedora CoreOS to disk, reboot, and machines come up with your SSH authorized key set</li> <li><code>flatcar-install</code> - PXE boot, install Flatcar Linux to disk, reboot, and machines come up with your SSH authorized key set</li> </ul> <p>These aren't exactly full clusters, but they show declarations and network provisioning.</p> <pre><code>$ cd fedora-coreos-install    # or flatcar-install\n</code></pre> <p>Note</p> <p>Fedora CoreOS images are only served via HTTPS, so your iPXE firmware must be compiled to support HTTPS downloads.</p> <p>Let's review the terraform config and learn a bit about Matchbox.</p>"},{"location":"getting-started/#provider","title":"Provider","text":"<p>Matchbox is configured as a provider platform for bare-metal resources.</p> <pre><code>// Configure the matchbox provider\nprovider \"matchbox\" {\n  endpoint    = var.matchbox_rpc_endpoint\n  client_cert = file(\"~/.matchbox/client.crt\")\n  client_key  = file(\"~/.matchbox/client.key\")\n  ca          = file(\"~/.matchbox/ca.crt\")\n}\n\nterraform {\n  required_providers {\n    ct = {\n      source  = \"poseidon/ct\"\n      version = \"0.10.0\"\n    }\n    matchbox = {\n      source = \"poseidon/matchbox\"\n      version = \"0.5.0\"\n    }\n  }\n}\n</code></pre>"},{"location":"getting-started/#profiles","title":"Profiles","text":"<p>Machine profiles specify the kernel, initrd, kernel args, Ignition Config, or other configs (e.g. templated Butane Config, generic) used to network boot and provision a bare-metal machine. The profile below would PXE boot machines using a Fedora CoreOS kernel and initrd (see assets to learn about caching for speed), perform a disk install, reboot (first boot from disk), and use a Fedora CoreOS Config to generate an Ignition config to provision.</p> <pre><code>// Fedora CoreOS profile\nresource \"matchbox_profile\" \"fedora-coreos-install\" {\n  name  = \"worker\"\n  kernel = \"https://builds.coreos.fedoraproject.org/prod/streams/${var.os_stream}/builds/${var.os_version}/x86_64/fedora-coreos-${var.os_version}-live-kernel-x86_64\"\n\n  initrd = [\n    \"--name main https://builds.coreos.fedoraproject.org/prod/streams/${var.os_stream}/builds/${var.os_version}/x86_64/fedora-coreos-${var.os_version}-live-initramfs.x86_64.img\"\n  ]\n\n  args = [\n    \"initrd=main\",\n    \"coreos.live.rootfs_url=https://builds.coreos.fedoraproject.org/prod/streams/${var.os_stream}/builds/${var.os_version}/x86_64/fedora-coreos-${var.os_version}-live-rootfs.x86_64.img\",\n    \"coreos.inst.install_dev=/dev/sda\",\n    \"coreos.inst.ignition_url=${var.matchbox_http_endpoint}/ignition?uuid=$${uuid}&amp;mac=$${mac:hexhyp}\"\n  ]\n\n  raw_ignition = data.ct_config.worker.rendered\n}\n\ndata \"ct_config\" \"worker\" {\n  content = templatefile(\"fcc/fedora-coreos.yaml\", {\n    ssh_authorized_key = var.ssh_authorized_key\n  })\n  strict = true\n}\n</code></pre>"},{"location":"getting-started/#groups","title":"Groups","text":"<p>Matcher groups match machines based on labels like MAC, UUID, etc. to different profiles and templates in machine-specific values. The group below does not have a <code>selector</code> block, so any machines which network boot from Matchbox will match this group and be provisioned using the <code>fedora-coreos-install</code> profile. Machines are matched to the most specific matching group.</p> <pre><code>// Default matcher group for machines\nresource \"matchbox_group\" \"default\" {\n  name    = \"default\"\n  profile = matchbox_profile.fedora-coreos-install.name\n}\n</code></pre>"},{"location":"getting-started/#variables","title":"Variables","text":"<p>Some Terraform variables are used in the examples. A quick way to set their value is by creating a <code>terraform.tfvars</code> file.</p> <pre><code>cp terraform.tfvars.example terraform.tfvars\n</code></pre> <pre><code>matchbox_http_endpoint = \"http://matchbox.example.com:8080\"\nmatchbox_rpc_endpoint  = \"matchbox.example.com:8081\"\nos_version             = \"36.20220906.3.2\"\nssh_authorized_key     = \"YOUR_SSH_KEY\"\n</code></pre>"},{"location":"getting-started/#apply","title":"Apply","text":"<p>Initialize the Terraform workspace. Then plan and apply the resources.</p> <pre><code>terraform init\n</code></pre> <pre><code>$ terraform apply\nApply complete! Resources: 4 added, 0 changed, 0 destroyed.\n</code></pre> <p>Matchbox serves configs to machines and respects query parameters, if you're interested:</p> <ul> <li>iPXE default - /ipxe</li> <li>Ignition default - /ignition</li> <li>Ignition post-install - /ignition?os=installed</li> </ul>"},{"location":"getting-started/#network","title":"Network","text":"<p>Matchbox can integrate with many on-premise network setups. It does not seek to be the DHCP server, TFTP server, or DNS server for the network. Instead, matchbox serves iPXE scripts as the entrypoint for provisioning network booted machines. PXE clients are supported by chainloading iPXE firmware.</p> <p>In the simplest case, an iPXE-enabled network can chain to Matchbox,</p> <pre><code># /var/www/html/ipxe/default.ipxe\nchain http://matchbox.foo:8080/boot.ipxe\n</code></pre> <p>Read network-setup.md for the complete range of options. Network admins have a great amount of flexibility:</p> <ul> <li>May keep using existing DHCP, TFTP, and DNS services</li> <li>May configure subnets, architectures, or specific machines to delegate to matchbox</li> <li>May place matchbox behind a menu entry (timeout and default to matchbox)</li> </ul> <p>If you've never setup a PXE-enabled network before or you're trying to setup a home lab, checkout the quay.io/poseidon/dnsmasq container image copy-paste examples and see the section about proxy-DHCP.</p>"},{"location":"getting-started/#boot","title":"Boot","text":"<p>Its time to network boot your machines. Use the BMC's remote management capabilities (may be vendor-specific) to set the boot device (on the next boot only) to PXE and power on each machine.</p> <pre><code>$ ipmitool -H node1.example.com -U USER -P PASS power off\n$ ipmitool -H node1.example.com -U USER -P PASS chassis bootdev pxe\n$ ipmitool -H node1.example.com -U USER -P PASS power on\n</code></pre> <p>Each machine should chainload iPXE, delegate to Matchbox, receive its iPXE config (or other supported configs) and begin the provisioning process. The examples assume machines are configured to boot from disk first and PXE only when requested, but you can write profiles for different cases.</p> <p>Once the install completes and the machine reboots, you can SSH.</p> <pre><code>$ ssh core@node1.example.com\n</code></pre> <p>To re-provision the machine for another purpose, run <code>terraform apply</code> and PXE boot machines again.</p>"},{"location":"getting-started/#going-further","title":"Going Further","text":"<p>Matchbox can be used to provision multi-node Fedora CoreOS or Flatcar Linux clusters at one or many on-premise sites if deployed in an HA way. Machines can be matched individually by MAC address, UUID, region, or other labels you choose. Installs can be made much faster by caching images in the built-in HTTP assets server.</p> <p>Ignition can be used to partition disks, create file systems, write systemd units, write networkd configs or regular files, and create users. Nodes can be network provisioned into a complete cluster system that meets your needs. For example, see Typhoon.</p>"},{"location":"grub/","title":"GRUB2 netboot","text":"<p>Use GRUB to network boot UEFI hardware.</p>"},{"location":"grub/#requirements","title":"Requirements","text":"<p>For local development, install the dependencies for libvirt with UEFI.</p> <ul> <li>UEFI with QEMU</li> </ul> <p>Ensure that you've gone through the matchbox with docker and matchbox guides and understand the basics.</p>"},{"location":"grub/#containers","title":"Containers","text":"<p>Run <code>matchbox</code> according to matchbox with Docker, but mount the grub group example. Then start the <code>poseidon/dnsmasq</code> Docker image, which bundles a <code>grub.efi</code>.</p> <pre><code>$ sudo docker run --rm --cap-add=NET_ADMIN quay.io/poseidon/dnsmasq -d -q --dhcp-range=172.17.0.43,172.17.0.99 --enable-tftp --tftp-root=/var/lib/tftpboot --dhcp-match=set:efi-bc,option:client-arch,7 --dhcp-boot=tag:efi-bc,grub.efi --dhcp-userclass=set:grub,GRUB2 --dhcp-boot=tag:grub,\"(http;matchbox.foo:8080)/grub\",\"172.17.0.2\" --log-queries --log-dhcp --dhcp-option=3,172.17.0.1 --dhcp-userclass=set:ipxe,iPXE --dhcp-boot=tag:pxe,undionly.kpxe --dhcp-boot=tag:ipxe,http://matchbox.foo:8080/boot.ipxe --address=/matchbox.foo/172.17.0.2\n</code></pre>"},{"location":"grub/#client-vm","title":"Client VM","text":"<p>Create UEFI VM nodes which have known hardware attributes.</p> <pre><code>$ sudo ./scripts/libvirt create-uefi\n</code></pre> <p>Create a VM to verify the machine network boots.</p> <pre><code>$ sudo virt-install --name uefi-test --boot=uefi,network --disk pool=default,size=4 --network=bridge=docker0,model=e1000 --memory=1024 --vcpus=1 --os-type=linux --noautoconsole\n</code></pre>"},{"location":"ignition/","title":"Ignition Configs","text":"<p>Ignition configs define how disks should be provisioned (on network boot and first-boot from disk) to partition disks, write files (regular files, systemd units, networkd units, etc.), and configure users. Ignition is used by:</p> <ul> <li>Fedora CoreOS</li> <li>RHEL CoreOS</li> <li>Flatcar Linux</li> </ul> <p>See the Ignition Config v3.x specs for details.</p>"},{"location":"ignition/#usage","title":"Usage","text":"<p>Ignition configs can be added to the <code>/var/lib/matchbox/ignition</code> directory or in an <code>ignition</code> subdirectory of a custom <code>-data-path</code>. Ignition configs must end in <code>.ign</code> or <code>ignition</code>.</p> <pre><code>/var/lib/matchbox\n \u251c\u2500\u2500 ignition\n \u2502\u00a0\u00a0 \u2514\u2500\u2500 k8s-controller.ign\n \u2502\u00a0\u00a0 \u2514\u2500\u2500 k8s-worker.ign\n \u2514\u2500\u2500 profiles\n</code></pre> <p>Matchbox Profiles can set an Ignition config for provisioning machines. Specify the Ignition config in a Profile with <code>ignition_id</code>.</p> <pre><code>{\n  \"id\": \"worker\",\n  \"name\": \"My Profile\",\n  \"boot\": {\n    ...\n  },\n  \"ignition_id\": \"my-ignition.ign\"\n}\n</code></pre> <p>When PXE booting, set kernel arguments depending on the OS (e.g. <code>ignition.firstboot</code> on FCOS, <code>flatcar.first_boot=yes</code> on Flatcar).</p> <ul> <li>Fedora CoreOS</li> <li>Flatcar Linux</li> </ul> <p>Point the <code>ignition.config.url</code> or <code>flatcar.config.url</code> to point to the <code>matchbox</code> Ignition endpoint.</p> <p>Matchbox parses Ignition configs (e.g. <code>.ign</code> or <code>.ignition</code>) at spec v3.3 or below and renders to the current supported version (v3.3). This relies on Ignition's forward compatibility.</p>"},{"location":"ignition/#writing-configs","title":"Writing Configs","text":"<p>Ignition configs can be prepared externally and loaded via the gRPC API, rather than writing Ignition by hand.</p>"},{"location":"ignition/#terraform","title":"Terraform","text":"<p>Terraform can be used to prepare Ignition configs, while providing integrations with external systems and rich templating. Using tools like poseidon/terraform-provider-ct, you can write Butane config (an easier YAML format), validate configs, and load Ignition into Matchbox (examples).</p> <p>Define a Butane config for Fedora CoreOS or Flatcar Linux:</p> <pre><code>variant: fcos\nversion: 1.5.0\npasswd:\n  users:\n    - name: core\n      ssh_authorized_keys:\n        - ssh-key foo\n</code></pre> <pre><code>variant: flatcar\nversion: 1.1.0\npasswd:\n  users:\n    - name: core\n      ssh_authorized_keys:\n        - ssh-key foo\n</code></pre> <p>Define a <code>ct_config</code> data source with strict validation. Optionally use Terraform templating.</p> <pre><code>data \"ct_config\" \"worker\" {\n  content      = file(\"worker.yaml\")\n  strict       = true\n  pretty_print = false\n\n  snippets = [\n    file(\"units.yaml\"),\n    file(\"storage.yaml\"),\n  ]\n}\n</code></pre> <p>Then render the Butane config to Ignition and use it in a Matchbox Profile.</p> <pre><code>resource \"matchbox_profile\" \"fedora-coreos-install\" {\n  name   = \"worker\"\n  kernel = \"/assets/fedora-coreos/fedora-coreos-${var.os_version}-live-kernel-x86_64\"\n  initrd = [\n    \"--name main /assets/fedora-coreos/fedora-coreos-${var.os_version}-live-initramfs.x86_64.img\"\n  ]\n\n  args = [\n    \"initrd=main\",\n    \"coreos.live.rootfs_url=${var.matchbox_http_endpoint}/assets/fedora-coreos/fedora-coreos-${var.os_version}-live-rootfs.x86_64.img\",\n    \"coreos.inst.install_dev=/dev/vda\",\n    \"coreos.inst.ignition_url=${var.matchbox_http_endpoint}/ignition?uuid=$${uuid}&amp;mac=$${mac:hexhyp}\",\n  ]\n\n  raw_ignition = data.ct_config.worker.rendered\n}\n</code></pre> <p>See the Terraform examples for details.</p>"},{"location":"ignition/#butane","title":"Butane","text":"<p>The Butane command line tool can be used to convert Butane configs (an easier YAML format) to Ignition. Then you can use the Matchbox gRPC API to upload the rendered Ignition to Matchbox for serving to machines on boot.</p> <p>See examples/ignition for Butane config examples.</p>"},{"location":"ignition/#matchbox-rendering","title":"Matchbox Rendering","text":"<p>While Matchbox recommends preparing Ignition configs externally (e.g. using Terraform's rich templating), Matchbox does still support limited templating and translation features with a builtin Butane converter.</p> <p>Specify a Butane config in a Profile with <code>ignition_id</code> (file must not end in <code>.ign</code> or <code>.ignition</code>).</p> <pre><code>{\n  \"id\": \"worker\",\n  \"name\": \"My Profile\",\n  \"boot\": {\n    ...\n  },\n  \"ignition_id\": \"butane.yaml\"\n}\n</code></pre> <p>Here is an example Butane config with Matchbox template elements. Template files may contain Go template elements which will be interpreted using group metadata, selectors, and query params.</p> <pre><code>variant: flatcar\nversion: 1.1.0\nstorage:\n  files:\n    - path: /var/home/core/foo\n      mode: 0644\n      contents:\n        inline: |\n          {{.example_contents}}\n\n{{ if index . \"ssh_authorized_keys\" }}\npasswd:\n  users:\n    - name: core\n      ssh_authorized_keys:\n        {{ range $element := .ssh_authorized_keys }}\n        - {{$element}}\n        {{end}}\n{{end}}\n</code></pre> <p>Matchbox will use the Butane library to config to the current supported Ignition version. This relies on Ignition's forward compatibility.</p>"},{"location":"machine-lifecycle/","title":"Lifecycle of a physical machine","text":""},{"location":"machine-lifecycle/#about-boot-environment","title":"About boot environment","text":"<p>Physical machines network boot in an network boot environment with DHCP/TFTP/DNS services or with poseidon/dnsmasq.</p> <p><code>matchbox</code> serves iPXE or GRUB configs via HTTP to machines based on Group selectors (e.g. UUID, MAC, region, etc.) and machine Profiles. Kernel and initrd images are fetched and booted with Ignition to install CoreOS Container Linux. The \"first boot\" Ignition config if fetched and Container Linux is installed.</p> <p>Container Linux boots (\"first boot\" from disk) and runs Ignition to provision its disk with systemd units, files, keys, and more to become a cluster node. Systemd units may fetch metadata from a remote source if needed.</p> <p>Coordinated auto-updates are enabled. Systems like fleet or Kubernetes coordinate container services. IPMI, vendor utilities, or first-boot are used to re-provision machines into new roles.</p>"},{"location":"machine-lifecycle/#machine-lifecycle","title":"Machine lifecycle","text":""},{"location":"matchbox/","title":"matchbox","text":"<p><code>matchbox</code> is an HTTP and gRPC service that renders signed Ignition configs, cloud-configs, network boot configs, and metadata to machines to create CoreOS Container Linux clusters. <code>matchbox</code> maintains Group definitions which match machines to profiles based on labels (e.g. MAC address, UUID, stage, region). A Profile is a named set of config templates (e.g. iPXE, GRUB, Ignition config, Cloud-Config, generic configs). The aim is to use Container Linux's early-boot capabilities to provision Container Linux machines.</p> <p>Network boot endpoints provide PXE, iPXE, GRUB support. <code>matchbox</code> can be run a binary or as a container.</p> <p></p>"},{"location":"matchbox/#getting-started","title":"Getting started","text":"<p>Get started running <code>matchbox</code> on your Linux machine, with Docker.</p> <ul> <li>matchbox with Docker</li> </ul>"},{"location":"matchbox/#flags","title":"Flags","text":"<p>See configuration flags and variables.</p>"},{"location":"matchbox/#api","title":"API","text":"<ul> <li>HTTP API</li> <li>gRPC API</li> </ul>"},{"location":"matchbox/#data","title":"Data","text":"<p>A <code>Store</code> stores machine Groups, Profiles, and associated Ignition configs, cloud-configs, and generic configs. By default, <code>matchbox</code> uses a <code>FileStore</code> to search a <code>-data-path</code> for these resources.</p> <p>Prepare <code>/var/lib/matchbox</code> with <code>groups</code>, <code>profile</code>, <code>ignition</code>, <code>cloud</code>, and <code>generic</code> subdirectories. You may wish to keep these files under version control.</p> <pre><code> /var/lib/matchbox\n \u251c\u2500\u2500 cloud\n \u2502\u00a0\u00a0 \u251c\u2500\u2500 cloud.yaml.tmpl\n \u2502\u00a0\u00a0 \u2514\u2500\u2500 worker.sh.tmpl\n \u251c\u2500\u2500 ignition\n \u2502\u00a0\u00a0 \u2514\u2500\u2500 worker.ign\n \u2502\u00a0\u00a0 \u2514\u2500\u2500 butane.yaml.tmpl\n \u2502\u00a0\u00a0 \u2514\u2500\u2500 butane.yaml\n \u251c\u2500\u2500 generic\n \u2502\u00a0\u00a0 \u2514\u2500\u2500 config.yaml\n \u2502\u00a0\u00a0 \u2514\u2500\u2500 setup.cfg\n \u2502\u00a0\u00a0 \u2514\u2500\u2500 datacenter-1.tmpl\n \u251c\u2500\u2500 groups\n \u2502\u00a0\u00a0 \u2514\u2500\u2500 default.json\n \u2502\u00a0\u00a0 \u2514\u2500\u2500 node1.json\n \u2502\u00a0\u00a0 \u2514\u2500\u2500 us-central1-a.json\n \u2514\u2500\u2500 profiles\n     \u2514\u2500\u2500 etcd.json\n     \u2514\u2500\u2500 worker.json\n</code></pre> <p>The examples directory is a valid data directory with some pre-defined configs. Note that <code>examples/groups</code> contains many possible groups in nested directories for demo purposes (tutorials pick one to mount). Your machine groups should be kept directly inside the <code>groups</code> directory as shown above.</p>"},{"location":"matchbox/#profiles","title":"Profiles","text":"<p>Profiles reference an Ignition config, Butane Config, Cloud-Config, and/or generic config by name and define network boot settings.</p> <pre><code>{\n  \"id\": \"etcd\",\n  \"name\": \"Container Linux with etcd2\",\n  \"cloud_id\": \"\",\n  \"ignition_id\": \"worker.ign\",\n  \"generic_id\": \"some-service.cfg\",\n  \"boot\": {\n    \"kernel\": \"/assets/coreos/1967.3.0/coreos_production_pxe.vmlinuz\",\n    \"initrd\": [\"/assets/coreos/1967.3.0/coreos_production_pxe_image.cpio.gz\"],\n    \"args\": [\n      \"coreos.config.url=http://matchbox.foo:8080/ignition?uuid=${uuid}&amp;mac=${mac:hexhyp}\",\n      \"coreos.first_boot=yes\",\n      \"coreos.autologin\"\n    ]\n  },\n}\n</code></pre> <p>The <code>\"boot\"</code> settings will be used to render configs to network boot programs such as iPXE or GRUB. You may reference remote kernel and initrd assets or local assets.</p> <p>To use Ignition, set the <code>coreos.config.url</code> kernel option to reference the <code>matchbox</code> Ignition endpoint, which will render the <code>ignition_id</code> file. Be sure to add the <code>coreos.first_boot</code> option as well.</p> <p>To use cloud-config, set the <code>cloud-config-url</code> kernel option to reference the <code>matchbox</code> Cloud-Config endpoint, which will render the <code>cloud_id</code> file.</p>"},{"location":"matchbox/#groups","title":"Groups","text":"<p>Groups define selectors which match zero or more machines. Machine(s) matching a group will boot and provision according to the group's <code>Profile</code>.</p> <p>Create a group definition with a <code>Profile</code> to be applied, selectors for matching machines, and any <code>metadata</code> needed to render templated configs. For example <code>/var/lib/matchbox/groups/node1.json</code> matches a single machine with MAC address <code>52:54:00:89:d8:10</code>.</p> <pre><code># /var/lib/matchbox/groups/node1.json\n{\n  \"name\": \"node1\",\n  \"profile\": \"etcd\",\n  \"selector\": {\n    \"mac\": \"52:54:00:89:d8:10\"\n  },\n  \"metadata\": {\n    \"fleet_metadata\": \"role=etcd,name=node1\",\n    \"etcd_name\": \"node1\",\n    \"etcd_initial_cluster\": \"node1=http://node1.example.com:2380,node2=http://node2.example.com:2380,node3=http://node3.example.com:2380\"\n  }\n}\n</code></pre> <p>Meanwhile, <code>/var/lib/matchbox/groups/proxy.json</code> acts as the default machine group since it has no selectors.</p> <pre><code>{\n  \"name\": \"etcd-proxy\",\n  \"profile\": \"etcd-proxy\",\n  \"metadata\": {\n    \"fleet_metadata\": \"role=etcd-proxy\",\n    \"etcd_initial_cluster\": \"node1=http://node1.example.com:2380,node2=http://node2.example.com:2380,node3=http://node3.example.com:2380\"\n  }\n}\n</code></pre> <p>For example, a request to <code>/ignition?mac=52:54:00:89:d8:10</code> would render the Ignition template in the \"etcd\" <code>Profile</code>, with the machine group's metadata. A request to <code>/ignition</code> would match the default group (which has no selectors) and render the Ignition in the \"etcd-proxy\" Profile. Avoid defining multiple default groups as resolution will not be deterministic.</p>"},{"location":"matchbox/#reserved-selectors","title":"Reserved selectors","text":"<p>Group selectors can use any key/value pairs you find useful. However, several labels have a defined purpose and will be normalized or parsed specially.</p> <ul> <li><code>uuid</code> - machine UUID</li> <li><code>mac</code> - network interface physical address (normalized MAC address)</li> <li><code>hostname</code> - hostname reported by a network boot program</li> <li><code>serial</code> - serial reported by a network boot program</li> </ul>"},{"location":"matchbox/#config-templates","title":"Config templates","text":"<p>Profiles can reference various templated configs. Ignition configs can be provided directly or rendered fro Butane Config template files. Cloud-Config templates files can be used to render a script or Cloud-Config. Generic template files can be used to render arbitrary untyped configs (experimental). Each template may contain Go template elements which will be rendered with machine group metadata, selectors, and query params.</p> <p>For details and examples:</p> <ul> <li>Ignition (or Butane)</li> <li>Cloud-Config</li> </ul>"},{"location":"matchbox/#variables","title":"Variables","text":"<p>Within Butane Config templates, Cloud-Config templates, or generic templates, you can use group metadata, selectors, or request-scoped query params. For example, a request <code>/generic?mac=52-54-00-89-d8-10&amp;foo=some-param&amp;bar=b</code> would match the <code>node1.json</code> machine group shown above. If the group's profile (\"etcd\") referenced a generic template, the following variables could be used.</p> <pre><code># Untyped generic config file\n# Selector\n{{.mac}}                # 52:54:00:89:d8:10 (normalized)\n# Metadata\n{{.etcd_name}}          # node1\n{{.fleet_metadata}}     # role=etcd,name=node1\n# Query\n{{.request.query.mac}}  # 52:54:00:89:d8:10 (normalized)\n{{.request.query.foo}}  # some-param\n{{.request.query.bar}}  # b\n# Special Addition\n{{.request.raw_query}}  # mac=52:54:00:89:d8:10&amp;foo=some-param&amp;bar=b\n</code></pre> <p>Note that <code>.request</code> is reserved for these purposes so group metadata with data nested under a top level \"request\" key will be overwritten.</p>"},{"location":"matchbox/#assets","title":"Assets","text":"<p><code>matchbox</code> can serve <code>-assets-path</code> static assets at <code>/assets</code>. This is helpful for reducing bandwidth usage when serving the kernel and initrd to network booted machines. The default assets-path is <code>/var/lib/matchbox/assets</code> or you can pass <code>-assets-path=\"\"</code> to disable asset serving.</p> <pre><code>matchbox.foo/assets/\n\u2514\u2500\u2500 coreos\n    \u2514\u2500\u2500 VERSION\n        \u251c\u2500\u2500 coreos_production_pxe.vmlinuz\n        \u2514\u2500\u2500 coreos_production_pxe_image.cpio.gz\n</code></pre> <p>For example, a <code>Profile</code> might refer to a local asset <code>/assets/coreos/VERSION/coreos_production_pxe.vmlinuz</code> instead of <code>http://stable.release.core-os.net/amd64-usr/VERSION/coreos_production_pxe.vmlinuz</code>.</p> <p>See the get-fedora-coreos or get-flatcar scripts to quickly download, verify, and place image assets.</p>"},{"location":"matchbox/#network","title":"Network","text":"<p><code>matchbox</code> does not implement or exec a DHCP/TFTP server. Read network setup or use the poseidon/dnsmasq image if you need a quick DHCP, proxyDHCP, TFTP, or DNS setup.</p>"},{"location":"matchbox/#going-further","title":"Going further","text":"<ul> <li>gRPC API Usage</li> <li>Metadata</li> <li>OpenPGP Signing</li> </ul>"},{"location":"network-booting/","title":"Network boot environments","text":"<p>This guide reviews network boot protocols and the different ways client machines can be PXE booted.</p>"},{"location":"network-booting/#pxe","title":"PXE","text":"<p>The Preboot eXecution Environment (PXE) defines requirements for consistent, hardware-independent network-based machine booting and configuration. Formally, PXE specifies pre-boot protocol services that client NIC firmware must provide (DHCP, TFTP, UDP/IP), specifies boot firmware requirements, and defines a client-server protocol for obtaining a network boot program (NBP) which automates OS installation and configuration.</p> <p></p> <p>At power-on, if a client machine's BIOS or UEFI boot firmware is set to perform network booting, the network interface card's PXE firmware broadcasts a DHCPDISCOVER packet identifying itself as a PXEClient to the network environment.</p> <p>The network environment can be set up in a number of ways, which we'll discuss. In the simplest, a PXE-enabled DHCP Server responds with a DHCPOFFER with Options, which include a TFTP server IP (\"next server\") and the name of an NBP (\"boot filename\") to download (e.g. pxelinux.0). PXE firmware then downloads the NBP over TFTP and starts it. Finally, the NBP loads configs, scripts, and/or images it requires to run an OS.</p>"},{"location":"network-booting/#network-boot-programs","title":"Network boot programs","text":"<p>Machines can be booted and configured with CoreOS Container Linux using several network boot programs and approaches. Let's review them. If you're new to network booting or unsure which to choose, iPXE is a reasonable and flexible choice.</p>"},{"location":"network-booting/#pxelinux","title":"PXELINUX","text":"<p>PXELINUX is a common network boot program which loads a config file from <code>mybootdir/pxelinux.cfg/</code>  over TFTP. The file is chosen based on the client's UUID, MAC address, IP address, or a default.</p> <pre><code>$ mybootdir/pxelinux.cfg/b8945908-d6a6-41a9-611d-74a6ab80b83d\n$ mybootdir/pxelinux.cfg/default\n</code></pre> <p>Here is an example PXE config file which boots a Container Linux image hosted on the TFTP server.</p> <pre><code>default coreos\nprompt 1\ntimeout 15\n\ndisplay boot.msg\n\nlabel coreos\n  menu default\n  kernel coreos_production_pxe.vmlinuz\n  append initrd=coreos_production_pxe_image.cpio.gz cloud-config-url=http://example.com/pxe-cloud-config.yml\n</code></pre> <p>PXELINUX then downloads the specified kernel and init RAM filesystem images with TFTP.</p> <p>This approach has a number of drawbacks. TFTP can be slow, managing config files can be tedious, and using different ignition or cloud configs on different machines requires separate pxelinux configs. These limitations spurred the development of various enhancements to PXE, discussed next.</p>"},{"location":"network-booting/#ipxe","title":"iPXE","text":"<p>iPXE is an enhanced implementation of the PXE client firmware and a network boot program which uses iPXE scripts rather than config files and can download scripts and images with HTTP.</p> <p></p> <p>A DHCPOFFER to iPXE client firmware specifies an HTTP boot script such as <code>http://matchbox.foo/boot.ipxe</code>.</p> <p>Here is an example iPXE script for booting the remote Container Linux stable image.</p> <pre><code>#!ipxe\n\nset base-url http://stable.release.core-os.net/amd64-usr/current\nkernel ${base-url}/coreos_production_pxe.vmlinuz cloud-config-url=http://provisioner.example.net/cloud-config.yml\ninitrd ${base-url}/coreos_production_pxe_image.cpio.gz\nboot\n</code></pre> <p>A TFTP server is used only to provide the <code>undionly.kpxe</code> boot program to older PXE firmware in order to bootstrap into iPXE.</p> <p>CoreOS <code>matchbox</code> can render signed iPXE scripts to machines based on their hardware attributes. Setup involves configuring your DHCP server to point iPXE clients to the <code>matchbox</code> iPXE endpoint.</p>"},{"location":"network-booting/#dhcp","title":"DHCP","text":"<p>Many networks have DHCP services which are impractical to modify or disable. Company DHCP servers are governed by network admin policies and home/office networks often have routers running a DHCP service which cannot supply PXE options to PXE clients.</p> <p>To address this, PXE client firmware listens for DHCPOFFERs from a non-PXE DHCP server and a PXE-enabled proxyDHCP server configured to respond with the next server and boot filename only. Client firmware combines the two responses as if they had come from a single PXE-enabled DHCP server.</p> <p></p>"},{"location":"network-setup/","title":"Network setup","text":"<p>This guide shows how to create a DHCP/TFTP/DNS network boot environment to boot and provision BIOS/PXE, iPXE, or UEFI client machines.</p> <p>Matchbox serves iPXE scripts over HTTP to serve as the entrypoint for provisioning clusters. It does not implement or exec a DHCP, TFTP, or DNS server. Instead, configure your network environment to point to Matchbox or use the convenient quay.io/poseidon/dnsmasq container image (used in local QEMU/KVM setup).</p> <p>Note: These are just suggestions. Your network administrator or system administrator should choose the right network setup for your company.</p>"},{"location":"network-setup/#requirements","title":"Requirements","text":"<p>Client hardware must have a network interface which supports PXE or iPXE.</p>"},{"location":"network-setup/#goals","title":"Goals","text":"<ul> <li>Add a DNS name which resolves to a <code>matchbox</code> deploy.</li> <li>Chainload BIOS clients (legacy PXE) to iPXE (undionly.kpxe)</li> <li>Chainload UEFI clients to iPXE (ipxe.efi)</li> <li>Point iPXE clients to <code>http://matchbox.example.com:port/boot.ipxe</code></li> <li>Point GRUB clients to <code>http://matchbox.example.com:port/grub</code></li> </ul>"},{"location":"network-setup/#setup","title":"Setup","text":"<p>Many companies already have DHCP/TFTP configured to \"PXE-boot\" PXE/iPXE clients. In this case, machines (or a subset of machines) can be made to chainload from <code>chain http://matchbox.example.com:port/boot.ipxe</code>. Older PXE clients can be made to chainload into iPXE to be able to fetch subsequent configs via HTTP.</p> <p>On simpler networks, such as what a developer might have at home, a relatively inflexible DHCP server may be in place, with no TFTP server. In this case, a proxy DHCP server can be run alongside a non-PXE capable DHCP server.</p> <p>This diagram can point you to the right section(s) of this document.</p> <p></p> <p>The setup of DHCP, TFTP, and DNS services on a network varies greatly. If you wish to use Docker to quickly run DHCP, proxyDHCP TFTP, or DNS services, use poseidon/dnsmasq.</p>"},{"location":"network-setup/#dns","title":"DNS","text":"<p>Add a DNS entry (e.g. <code>matchbox.example.com</code>, <code>provisoner.mycompany-internal</code>) that resolves to a deployment of the CoreOS <code>matchbox</code> service from machines you intend to boot and provision.</p> <pre><code>$ dig matchbox.example.com\n</code></pre> <p>If you deployed <code>matchbox</code> to a known IP address (e.g. dedicated host, load balanced endpoint, Kubernetes NodePort) and use <code>dnsmasq</code>, a domain name to IPv4/IPv6 address mapping could be added to the <code>/etc/dnsmasq.conf</code>.</p> <pre><code># dnsmasq.conf\naddress=/matchbox.example.com/172.18.0.2\n</code></pre>"},{"location":"network-setup/#ipxe","title":"iPXE","text":"<p>Networks which already run DHCP and TFTP services to network boot PXE/iPXE clients can add an iPXE config to delegate or <code>chain</code> to the matchbox service's iPXE entrypoint.</p> <pre><code># /var/www/html/ipxe/default.ipxe\nchain http://matchbox.example.com:8080/boot.ipxe\n</code></pre> <p>You can chainload from a menu entry or use other iPXE commands if you need to do more than simple delegation.</p>"},{"location":"network-setup/#pxe-enabled-dhcp","title":"PXE-enabled DHCP","text":"<p>Configure your DHCP server to supply options to older PXE client firmware to specify the location of an iPXE or GRUB network boot program on your TFTP server. Send clients to the <code>matchbox</code> iPXE script or GRUB config endpoints.</p> <p>Here is an example <code>/etc/dnsmasq.conf</code>:</p> <pre><code>dhcp-range=192.168.1.1,192.168.1.254,30m\n\nenable-tftp\ntftp-root=/var/lib/tftpboot\n\n# Legacy PXE\ndhcp-match=set:bios,option:client-arch,0\ndhcp-boot=tag:bios,undionly.kpxe\n\n# UEFI\ndhcp-match=set:efi32,option:client-arch,6\ndhcp-boot=tag:efi32,ipxe.efi\ndhcp-match=set:efibc,option:client-arch,7\ndhcp-boot=tag:efibc,ipxe.efi\ndhcp-match=set:efi64,option:client-arch,9\ndhcp-boot=tag:efi64,ipxe.efi\n\n# iPXE - chainload to matchbox ipxe boot script\ndhcp-userclass=set:ipxe,iPXE\ndhcp-boot=tag:ipxe,http://matchbox.example.com:8080/boot.ipxe\n\n# verbose\nlog-queries\nlog-dhcp\n\n# static DNS assignments\naddress=/matchbox.example.com/192.168.1.100\n\n# (optional) disable DNS and specify alternate\n# port=0\n# dhcp-option=6,192.168.1.100\n</code></pre> <p>Add ipxe.efi and unidonly.kpxe to your tftp-root (e.g. <code>/var/lib/tftpboot</code>).</p> <pre><code>$ sudo systemctl start dnsmasq\n$ sudo firewall-cmd --add-service=dhcp --add-service=tftp [--add-service=dns]\n$ sudo firewall-cmd --list-services\n</code></pre> <p>See dnsmasq below to run dnsmasq with a container.</p>"},{"location":"network-setup/#proxy-dhcp","title":"Proxy-DHCP","text":"<p>Alternately, a proxy-DHCP server can be run alongside an existing non-PXE DHCP server. The proxy DHCP server provides only the next server and boot filename Options, leaving IP allocation to the DHCP server. Clients listen for both DHCP offers and merge the responses as though they had come from one PXE-enabled DHCP server.</p> <p>Example <code>/etc/dnsmasq.conf</code>:</p> <pre><code>dhcp-range=192.168.1.1,proxy,255.255.255.0\n\nenable-tftp\ntftp-root=/var/lib/tftpboot\n\n# if request comes from older PXE ROM, chainload to iPXE (via TFTP)\npxe-service=tag:#ipxe,x86PC,\"PXE chainload to iPXE\",undionly.kpxe\n# if request comes from iPXE user class, set tag \"ipxe\"\ndhcp-userclass=set:ipxe,iPXE\n# point ipxe tagged requests to the matchbox iPXE boot script (via HTTP)\npxe-service=tag:ipxe,x86PC,\"iPXE\",http://matchbox.example.com:8080/boot.ipxe\n\n# verbose\nlog-queries\nlog-dhcp\n</code></pre> <p>Add unidonly.kpxe (and undionly.kpxe.0 if using dnsmasq) to your tftp-root (e.g. <code>/var/lib/tftpboot</code>).</p> <pre><code>$ sudo systemctl start dnsmasq\n$ sudo firewall-cmd --add-service=dhcp --add-service=tftp [--add-service=dns]\n$ sudo firewall-cmd --list-services\n</code></pre> <p>See dnsmasq below to run dnsmasq with a container.</p>"},{"location":"network-setup/#configurable-tftp","title":"Configurable TFTP","text":"<p>If your DHCP server is configured to network boot PXE clients (but not iPXE clients), add a pxelinux.cfg to serve an iPXE kernel image and append commands.</p> <p>Example <code>/var/lib/tftpboot/pxelinux.cfg/default</code>:</p> <pre><code>timeout 10\ndefault iPXE\nLABEL iPXE\nKERNEL ipxe.lkrn\nAPPEND dhcp &amp;&amp; chain http://matchbox.example.com:8080/boot.ipxe\n</code></pre> <p>Add ipxe.lkrn to <code>/var/lib/tftpboot</code> (see iPXE docs).</p>"},{"location":"network-setup/#poseidondnsmasq","title":"poseidon/dnsmasq","text":"<p>The quay.io/poseidon/dnsmasq container image can run DHCP, TFTP, and DNS services via docker. The image bundles <code>ipxe.efi</code>, <code>undionly.kpxe</code>, and <code>grub.efi</code> for convenience. See contrib/dnsmasq for details.</p> <p>Run DHCP, TFTP, and DNS on the host's network:</p> <pre><code>sudo docker run --rm --cap-add=NET_ADMIN --net=host quay.io/poseidon/dnsmasq \\\n  -d -q \\\n  --dhcp-range=192.168.1.3,192.168.1.254 \\\n  --enable-tftp --tftp-root=/var/lib/tftpboot \\\n  --dhcp-match=set:bios,option:client-arch,0 \\\n  --dhcp-boot=tag:bios,undionly.kpxe \\\n  --dhcp-match=set:efi32,option:client-arch,6 \\\n  --dhcp-boot=tag:efi32,ipxe.efi \\\n  --dhcp-match=set:efibc,option:client-arch,7 \\\n  --dhcp-boot=tag:efibc,ipxe.efi \\\n  --dhcp-match=set:efi64,option:client-arch,9 \\\n  --dhcp-boot=tag:efi64,ipxe.efi \\\n  --dhcp-userclass=set:ipxe,iPXE \\\n  --dhcp-boot=tag:ipxe,http://matchbox.example.com:8080/boot.ipxe \\\n  --address=/matchbox.example.com/192.168.1.2 \\\n  --log-queries \\\n  --log-dhcp\n</code></pre> <p>Run a proxy-DHCP and TFTP service on the host's network:</p> <pre><code>sudo docker run --rm --cap-add=NET_ADMIN --net=host quay.io/poseidon/dnsmasq \\\n  -d -q \\\n  --dhcp-range=192.168.1.1,proxy,255.255.255.0 \\\n  --enable-tftp --tftp-root=/var/lib/tftpboot \\\n  --dhcp-userclass=set:ipxe,iPXE \\\n  --pxe-service=tag:#ipxe,x86PC,\"PXE chainload to iPXE\",undionly.kpxe \\\n  --pxe-service=tag:ipxe,x86PC,\"iPXE\",http://matchbox.example.com:8080/boot.ipxe \\\n  --pxe-service=tag:#ipxe,X86-64_EFI,\"PXE chainload to iPXE UEFI\",ipxe.efi \\\n  --pxe-service=tag:ipxe,X86-64_EFI,\"iPXE UEFI\",http:///matchbox.example.com:8080/boot.ipxe \\\n  --log-queries \\\n  --log-dhcp\n</code></pre> <p>Be sure to allow enabled services in your firewall configuration.</p> <pre><code>$ sudo firewall-cmd --add-service=dhcp --add-service=tftp --add-service=dns\n</code></pre>"},{"location":"network-setup/#uefi","title":"UEFI","text":""},{"location":"network-setup/#development","title":"Development","text":"<p>Install the dependencies for QEMU with UEFI. Walk through the getting-started-with-docker tutorial. Launch client VMs using <code>create-uefi</code>.</p> <p>Create UEFI QEMU/KVM VMs attached to the <code>docker0</code> bridge.</p> <pre><code>$ sudo ./scripts/libvirt create-uefi\n</code></pre> <p>UEFI clients should chainload <code>ipxe.efi</code>, load iPXE and Ignition configs from Matchbox, and Container Linux should boot as usual.</p>"},{"location":"network-setup/#troubleshooting","title":"Troubleshooting","text":"<p>See troubleshooting.</p>"},{"location":"openpgp/","title":"OpenPGP signing","text":"<p>The <code>matchbox</code> OpenPGP signature endpoints serve detached binary and ASCII armored signatures of rendered configs, if enabled. Each config endpoint has corresponding signature endpoints, typically suffixed with <code>.sig</code> or <code>.asc</code>.</p> <p>To enable OpenPGP signing, provide the path to a secret keyring containing a single signing key with <code>-key-ring-path</code> or by setting <code>MATCHBOX_KEY_RING_PATH</code>. If a passphrase is required, set it via the <code>MATCHBOX_PASSPHRASE</code> environment variable.</p> <p>Here are example signature endpoints without their query parameters.</p> Endpoint Signature Endpoint ASCII Signature Endpoint iPXE <code>http://matchbox.foo/ipxe.sig</code> <code>http://matchbox.foo/ipxe.asc</code> GRUB2 <code>http://bootcf.foo/grub.sig</code> <code>http://matchbox.foo/grub.asc</code> Ignition <code>http://matchbox.foo/ignition.sig</code> <code>http://matchbox.foo/ignition.asc</code> Cloud-Config <code>http://matchbox.foo/cloud.sig</code> <code>http://matchbox.foo/cloud.asc</code> Metadata <code>http://matchbox.foo/metadata.sig</code> <code>http://matchbox.foo/metadata.asc</code> <p>In production, mount your signing keyring and source the passphrase from a Kubernetes secret. Use a signing subkey exported to a keyring by itself, which can be revoked by a primary key, if needed.</p> <p>To try it locally, you may use the test fixture keyring. Warning: The test fixture keyring is for examples only.</p>"},{"location":"openpgp/#verify","title":"Verify","text":"<p>Verify a signature response and config response from the command line using the public key. Notice that most configs have a trailing newline.</p> <p>Warning: The test fixture keyring is for examples only.</p> <pre><code>$ gpg --homedir sign/fixtures --verify sig_file response_file\ngpg: Signature made Mon 08 Feb 2016 11:37:03 PM PST using RSA key ID 9896356A\ngpg: sign/fixtures/trustdb.gpg: trustdb created\ngpg: Good signature from \"Fake Bare Metal Key (Do not use) &lt;do-not-use@example.com&gt;\"\ngpg: WARNING: This key is not certified with a trusted signature!\ngpg:          There is no indication that the signature belongs to the owner.\nPrimary key fingerprint: BE2F 12BC 3642 2594 570A  CCBB 8DC4 2020 9896 356A\n</code></pre>"},{"location":"openpgp/#signing-key-generation","title":"Signing key generation","text":"<p>Create a signing key or subkey according to your requirements and security policies. Here are some basic guides.</p>"},{"location":"openpgp/#gpg","title":"gpg","text":"<pre><code>$ mkdir -m 700 path/in/vault\n$ gpg --homedir path/in/vault --expert --gen-key\n...\n</code></pre>"},{"location":"openpgp/#gpg2","title":"gpg2","text":"<pre><code>$ mkdir -m 700 path/in/vault\n$ gpg2 --homedir path/in/vault --expert --gen-key\n...\n$ gpg2 --homedir path/in/vault --export-secret-key KEYID &gt; path/in/vault/secring.gpg\n</code></pre>"},{"location":"troubleshooting/","title":"Troubleshooting","text":""},{"location":"troubleshooting/#firewall","title":"Firewall","text":"<p>Running DHCP or proxyDHCP with <code>poseidon/dnsmasq</code> on a host requires that the Firewall allow DHCP and TFTP (for chainloading) services to run.</p>"},{"location":"troubleshooting/#port-collision","title":"Port collision","text":"<p>Running DHCP or proxyDHCP can cause port already in use collisions depending on what's running. Fedora runs bootp listening on udp/67 for example. Find the service using the port.</p> <pre><code>$ sudo lsof -i :67\n</code></pre> <p>Evaluate whether you can configure the existing service or whether you'd like to stop it and test with <code>poseidon/dnsmasq</code>.</p>"},{"location":"troubleshooting/#no-boot-filename-received","title":"No boot filename received","text":"<p>PXE client firmware did not receive a DHCP Offer with PXE-Options after several attempts. If you're using the <code>poseidon/dnsmasq</code> image with <code>-d</code>, each request should log to stdout. Using the wrong <code>-i</code> interface is the most common reason DHCP requests are not received. Otherwise, wireshark can be useful for investigating.</p>"},{"location":"dev/develop/","title":"Development","text":"<p>To develop <code>matchbox</code> locally, compile the binary and build the container image.</p>"},{"location":"dev/develop/#static-binary","title":"Static binary","text":"<p>Build the static binary.</p> <pre><code>$ make build\n</code></pre> <p>Test with vendored dependencies.</p> <pre><code>$ make test\n</code></pre>"},{"location":"dev/develop/#container-image","title":"Container image","text":"<p>Build a container image <code>coreos/matchbox:latest</code>.</p> <pre><code>$ make docker-image\n</code></pre>"},{"location":"dev/develop/#version","title":"Version","text":"<pre><code>$ ./bin/matchbox -version\n$ sudo docker run coreos/matchbox:latest -version\n</code></pre>"},{"location":"dev/develop/#run","title":"Run","text":"<p>Run the binary.</p> <pre><code>$ ./bin/matchbox -address=0.0.0.0:8080 -log-level=debug -data-path examples -assets-path examples/assets\n</code></pre> <p>Run the Docker image on <code>docker0</code>.</p> <pre><code>$ sudo docker run -p 8080:8080 --rm -v $PWD/examples:/var/lib/matchbox:Z -v $PWD/examples/groups/etcd:/var/lib/matchbox/groups:Z coreos/matchbox:latest -address=0.0.0.0:8080 -log-level=debug\n</code></pre>"},{"location":"dev/develop/#bootcmd","title":"bootcmd","text":"<p>Run <code>bootcmd</code> against the gRPC API of the service.</p> <pre><code>$ ./bin/bootcmd profile list --endpoints 172.18.0.2:8081 --cacert examples/etc/matchbox/ca.crt\n</code></pre>"},{"location":"dev/develop/#vendor","title":"Vendor","text":"<p>Add or update dependencies in <code>go.mod</code> and vendor.</p> <pre><code>make update\nmake vendor\n</code></pre>"},{"location":"dev/develop/#codegen","title":"Codegen","text":"<p>Generate code from proto definitions using <code>protoc</code> and the <code>protoc-gen-go</code> plugin.</p> <pre><code>$ make codegen\n</code></pre>"},{"location":"dev/release/","title":"Release guide","text":"<p>This guide covers releasing new versions of matchbox.</p>"},{"location":"dev/release/#version","title":"Version","text":"<p>Create a release commit which updates old version references.</p> <pre><code>$ export VERSION=v0.10.0\n</code></pre>"},{"location":"dev/release/#tag","title":"Tag","text":"<p>Tag, sign the release version, and push it to Github.</p> <pre><code>$ git tag -s vX.Y.Z -m 'vX.Y.Z'\n$ git push origin --tags\n$ git push origin main\n</code></pre>"},{"location":"dev/release/#images","title":"Images","text":"<p>Travis CI will build the Docker image and push it to Quay.io when the tag is pushed to master. Verify the new image and version.</p> <pre><code>$ sudo docker run quay.io/poseidon/matchbox:$VERSION -version\n</code></pre>"},{"location":"dev/release/#github-release","title":"Github release","text":"<p>Publish the release on Github with release notes.</p>"},{"location":"dev/release/#tarballs","title":"Tarballs","text":"<p>Build the release tarballs.</p> <pre><code>$ make release\n</code></pre> <p>Verify the reported version.</p> <pre><code>./_output/matchbox-v0.10.0-linux-amd64/matchbox -version\n</code></pre>"},{"location":"dev/release/#signing","title":"Signing","text":"<p>Release tarballs are signed by Dalton Hubble's GPG Key</p> <pre><code>make release-sign\n</code></pre> <p>Verify the signatures.</p> <pre><code>make release-verify\n</code></pre>"},{"location":"dev/release/#publish","title":"Publish","text":"<p>Upload the signed tarball(s) with the Github release. Promote the release from a <code>pre-release</code> to an official release.</p>"}]}